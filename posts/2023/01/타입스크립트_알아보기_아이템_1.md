---
title: "이펙티브 타입스크립트 1장"
tags:
  - effective_typescript
published: true
date: 2023-01-18 13:47:55
description: "1장 타입스크립트 알아보기 - 아이템 1: TS와 JS의 관계 이해하기"
---

# 이펙티브 타입스크립트 1장

---

## 아이템 1: TS와 JS의 관계 이해하기

JS는 브라우저에서 가벼운 처리를 위해 도입한

- 단일 스레드
- 비동기 모델

이라는 특징을 가지고 있었고 이는 단점으로 지적되어 왔지만, 현대의 멀티코어 병렬 프로그래밍 환경에는 적합한 메커니즘으로 인식되는 역설적인 상황이 벌어지고 있다.<br />
하지만 가장 치명적인 단점으로 **타입 불안정성**을 가지고 있었는데 TS가 대두되면서 이를 비판하던 목소리까지 잠재우고 있다.

### TS는 JS의 상위 집합

JS로 된 프로그램에 문법적인 오류가 없다면 유효한 TS 프로그램이라고 할 수 있다. 하지만 JS로 된 프로그램에 어떤 이슈가 존재한다면 문법적으로 오류가 아니더라도 타입 체커에게 지적당할 가능성이 높다.<br />
그러나 **문법의 유효성과 동작의 이슈는 각기 다른 독립적인 문제**다. TS는 동작에 이슈가 생기더라도 여전히 작성된 코드를 파싱하고 JS로 변환할 수 있다. 때문에 타입 체커를 통과하면서도 런타임 오류를 발생시키는 코드는 충분히 존재할 수 있다.

### 그럼에도 불구하고 TS를 사용하는 이유

> 타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아 내는 것

TS가 "정적" 타입 시스템이라는 것은 바로 이런 특징을 말하는 것이다. 하지만 타입 체커가 모든 오류를 찾아내지는 않는다.<br />

```js
const states = [
	{ name: "Alabama", capitol: "Montgomery" },
	{ name: "Alaska", capitol: "Juneau" },
	{ name: "Arizona", capitol: "Phoenix" },
];

for (const state of states) {
	console.log(state.capital);
}

/*
  js 출력값: 
    undefined
    undefined
    undefined

  ts 출력값: 
    "capital" 속성이 ... 형식에 없습니다.
    "capitol" 을(를) 사용하시겠습니까?
*/
```

위의 코드는 JS로 된 프로그램이라면 유효한 JS 이며 어떠한 오류도 없이 실행된다. 하지만 루프 내의 `state.capitol`은 의도한 코드가 아닌것이 분명하다. 이러한 경우에 타입체커는 추가적인 타입 구문 없이도 오류를 찾아낸다. 코드의 의도가 무엇인지 타입 구문을 통해 TS에게 알려줄 수 있기 때문에 **코드의 동작과 의도가 다른 부분**을 찾을 수 있다.<br />
하지만 TS가 제시한 해결책은 잘못되었다. 한 곳에서는 `capital`로 다른 곳에서는 `capitol`로 타이핑했지만 TS는 어느 쪽이 오타인지 판단하지 못한다. 따라서 다음과 같이 명시적으로 `state`를 선언하여 의도를 분명하게 하는것이 좋다.

```ts
interface State {
	name: string;
	capital: string;
}

const states: State[] = [
	{ name: "Alabama", capitol: "Montgomery" },
	{ name: "Alaska", capitol: "Juneau" },
	{ name: "Arizona", capitol: "Phoenix" },

	/* 
    객체 리터럴은 알려진 속성만 지정할 수 있지만
    "State" 형식에 "capitol"이 없습니다. 
    "capital"을 추가하려 했습니까?
    */
];
```

이제 오류가 어디에서 발생했는지를 찾을 수 있고, 제시된 해결책도 올바르다. **동작과 의도를 단일화 할 뿐만 아니라 의도를 명확하게 전달 가능하다.**

### 주의해야 할 점

TS의 타입 시스템은 JS의 런타임 동작을 "모델링"한다.<br />
대부분의 경우, TS는 JS의 런타임 동작을 따라가지만, 강제적인 형변환이 발생하는 코드는 타입이 제공하는 의도가 모호해지기 때문에 JS가 정상 동작함에도 타입체커가 오류로 가이드할 수 있다.<br />

```js
const x = 2 + "3"; // 정상, string 타입입니다.
const y = "2" + 3; // 정상, string 타입입니다.
```

위 예제는 다른 언어였다면 런타임 오류가 될만한 코드다. 하지만 TS의 타입체커는 정상적으로 인식한다.

```js
const a = null + 7; // 7
const b = [] + 12; // "12"
```

반면에 다음의 코드는 런타임 오류가 발생하지 않는 코드인데 타입 체커는 문제점을 표시한다. JS는 값을 반환하면서 형변환이 발생하는데, 형변환을 의도한 것이라면 타입 체커가 가이드하는 오류는 의미가 없다. 때문에 TS의 사용 목적에 맞게 타입이 변경되는 상황을 피하는것이 좋다.
